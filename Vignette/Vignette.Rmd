---
title: "Vignette: Simulation studies with `ValidationExplorer` under a fixed-effort design type"
author:
  - name: Jacob Oram
    email: jacoboram@montana.edu
    institute: msu
    correspondence: false
  - name: Katharine Banner
    email: katharine.banner@montana.edu
    institute: msu
    correspondence: false
  - name: Christian Stratton
    email: cstratton@middlebur.edu
    institute: middlebury
    correspondence: false
  - name: Kathryn M. Irvine
    email: kirvine@usgs.gov
    institute: norock
    correspondence: true
institute:
    - msu: Department of Mathematical Sciences, Montana State University, Bozeman, MT, USA
    - middlebury: Department of Mathematics and Statistics, Middlebury College, Middlebury, VT, USA
    - norock: U.S. Geological Survey, Northern Rocky Mountain Science Center, Bozeman, MT, USA
date: "`r Sys.Date()`"
output: 
  bookdown::pdf_document2: 
    number_sections: yes
    keep_tex: no
    toc: no
    pandoc_args:
      - '--lua-filter=lua-filters/scholarly-metadata.lua'
      - '--lua-filter=lua-filters/author-info-blocks/author-info-blocks.lua'
header-includes:
  - \usepackage{setspace}
  - \usepackage{float}
  - \usepackage{amsmath}
bibliography: Vignette.bib
abstract: "Our vignette demonstrates the use of the `ValidationExplorer` package to conduct statistical simulation studies that explore the costs and inferential properties (e.g., near nominal coverage and/or minimal estimation error) of alternative validation designs. 
Our functions allow the user to specify a suite of candidate validation designs using either a stratified sampling procedure or a fixed-effort design type. An example of the former is provided in the manuscript entitled 'ValidationExplorer`: Streamlined simulations to aid informed management decisions using bioacoustic data in the presence of misclassification', which was submitted to the Applications series of *Methods in Ecology and Evolution*. In this vignette, we provide an additional example of data simulation, model fitting, and visualization of simulation results when using a fixed-effort design type. Our demonstration here is intended to aid researchers and others to tailor a validation design that provides useful inference while also ensuring that the level of effort meets cost constraints. \\vfill"
---

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(nimble)
library(coda)
library(rstan)
library(parallel)
library(here)
library(kableExtra)
theme_set(theme_bw())

chunk_hook  <- knitr::knit_hooks$get("chunk") # single space code chunks
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- chunk_hook(x, options)
  paste0("\\linespread{1}\n", x, "\n\n\\linespread{1}")
})

devtools::load_all(path = "..")
```

------------------------------------------------------------------------

**Disclaimer:** This draft manuscript is distributed solely for the purposes of scientific peer review. Its content is deliberative and pre-decisional, so it must not be disclosed or released by reviewers. Because the manuscript has not yet been approved for publication by the U.S. Geological Survey (USGS), it does not represent any official USGS funding or policy. Any use of trade, firm, or product names is for descriptive purposes only and does not imply endorsement by the U.S. Government.

\newpage

```{=latex}
\setcounter{tocdepth}{4}
\tableofcontents
```
\newpage

\doublespacing

# Introduction

Automated recording units (ARUs) provide one of the main data sources for many contemporary monitoring programs that aim to provide inference about status and trends for assemblages of species [@loeb15]. As described in "`ValidationExplorer`: Streamlined simulations to aid informed management decisions using bioacoustic data in the presence of misclassification" (hereafter, "the main text"), substantial practical interest lies in identifying cost-effective validation designs that will allow a monitoring program to obtain its measurable objectives. We believe that statistical simulation studies are a valuable tool for evaluating the relative merits of candidate validation designs prior to gathering and validating ARU data, and it is our goal for `ValidationExplorer` to provide those tools. 

This vignette provides detailed demonstrations of the `ValidationExplorer` package under a fixed-effort design. As described in the main text, a validation design is composed of two parts: a random mechanism for selecting observations to be manually reviewed by experts ("validated"), and a percentage or proportion that controls the sample size. We refer to the random mechanism as the *design type* and the proportion as a the level of validation effort (LOVE). In our example, we assume a fixed effort (the design type) validation design, under which, $x\%$ of recordings obtained from the first visit to a site are validated by experts. The level of validation effort is controlled by the value of $x.$ In the following section we consider five possible LOVEs and show an example of a fixed effort design. 


# Conducting a simulation study with a fixed effort design type

## Step 0: Define measurable objectives and constraints

Recall from the main text that the first step -- before opening R and loading `ValidationExplorer` --  is to identify and write down the set of measurable objectives that the data will be used for. Suppose that, for this example, the measurable objectives and cost constraints are the same as those Section 3 of the main text: 

\begin{itemize}
  \item The measurable objective is to estimate relative activity parameters (denoted as $\lambda_k$) for each species with estimation error less than 1 call per night and with the expected width of 95\% posterior intervals less than 3 calls per night.
  \item The monitoring program can pay their expert bat biologists to validate at most 4000 recordings. WE make the assumption that all recordings are approximately the same cost to validate (i.e., rare species autoIDs are not necessarily more expensive or time consuming than extremely common ones). 
\end{itemize}

Suppose further that the species assemblage is the same as that in the main text. That is, we have six species of interest that co-occur. The existing prior knowledge (perhaps from another study) about the relative activity rates and occurrence probabilities for each species are summarized in Table \@ref(tab:assemblage). 

```{r assemblage, echo=FALSE}
psi <- c(0.6331, 0.6122, 0.8490, 0.6972, 0.2365, 0.7036)
lambda <- c(5.9347, 4.1603, 14.2532, 6.1985, 11.8649, 2.4050)

tibble(
  Species = c("Eptesicus fuscus (EPFU)", "Lasiurus cinereus (LACI)", 
              "Lasionycteris noctivagans (LANO)", "Myotis californicus (MYCA)", 
              "Myotis ciliolabrum (MYCI)", "Myotis evotis (MYEV)"),
  psi = psi, 
  lambda = lambda, 
) %>% 
  rename("$\\psi$" = "psi", "$\\lambda$" = "lambda") %>% 
  kbl(format = "latex", booktabs = TRUE, caption = "Prior knowledge of relative activity rates and occurrence probabilities for the six bat species of interest. These values will be used to simulate data. ")
```

## Step 1: Installing and loading required packages

Once measurable objectives and constraints are clearly defined, the next step is to load the required packages. For first time users, it may be necessary to install a number of dependencies, as shown by Table 1 in the main text. If you need to install a dependency or update the version, run the following, with `your_package_name_here` replaced by the name of the package: 

```{r installDepends, eval=FALSE, echo=TRUE}
install.packages("your_package_name_here")
```

After installing the necessary packages, load these libraries by calling

```{r libDepends, eval=FALSE, echo=TRUE, message=FALSE}
library(tidyverse)
library(nimble)
library(coda)
library(rstan)
library(parallel)
library(here)
```

Finally, install and load `ValidationExplorer` by running 

```{r installVE, echo=TRUE, eval=FALSE}
devtools::install_github(repo = "j-oram/ValidationExplorer")
library(ValidationExplorer)
```

Note: to knit this vignette, you may also need to install the `kableExtra` package. 

## Step 3: Simulate data {dataSimulation}

The first step in a simulation study is to simulate data under each of the candidate validation designs, which is accomplished with the `simulate_validatedData` function in `ValidationExplorer`. We begin by assigning values for the number of sites, visits, species, as well as the parameter values in Table \@ref(tab:assemblage):

```{r pars}
# Set the number of sites,species and visits
nsites <- 30
nspecies <- 6
nvisits <- 4

psi <- c(0.6331, 0.6122, 0.8490, 0.6972, 0.2365, 0.7036)
lambda <- c(5.9347, 4.1603, 14.2532, 6.1985, 11.8649, 2.4050)
```

Additionally, `simulate_validatedData` requires that the user supply misclassification probabilities in the form of a matrix, subject to the constraint that rows in the matrix sum to one. An easy way to simulate a matrix of probabilities that meet these criteria is to leverage the `rdirch` function from the `nimble` package:

```{r Theta}
# Simulate a hypothetical confusion matrix 
set.seed(10092024) 
Theta <- t(apply(diag(29, nspecies) + 1, 1, function(x) {nimble::rdirch(alpha = x)}))

print(Theta)
```
Note that the above definition of `Theta` places high values on the diagonal of the matrix, corresponding to a high probability of correct classification. To lower the diagonal values, change the specification of `diag(29, nspecies)` to a smaller value. For example: 

```{r anotherTheta}
another_Theta <- t(apply(diag(5, nspecies) + 1, 1, function(x) {nimble::rdirch(alpha = x)}))
print(another_Theta)
```
`another_Theta` has lower values on the diagonal, and greater off-diagonal values (i.e., higher probability of misclassification). If you have specific values you would like to use for the assumed classification probabilities, these can be supplied manually: 

```{r manTheta}
manual_Theta <- matrix(c(0.9, 0.05, 0.01, 0.01, 0.02, 0.01, 
                       0.01, 0.7, 0.21, 0.05, 0.02, 0.01,  
                       0.01, 0.01, 0.95, 0.01, 0.01, 0.01,
                       0.05, 0.05, 0.03, 0.82, 0.04, 0.01,
                       0.01, 0.015,  0.005,  0.005, 0.95, 0.015,
                       0.003, 0.007, 0.1, 0.04, 0.06, 0.79), 
                       byrow = TRUE, nrow = 6)

```

If you define the classifier manually, make sure the rows sum to 1 by running

```{r ThetaCheck}
all(rowSums(manual_Theta) == 1) # want this to return TRUE

# If the above returns FALSE, see which one is not 1: 
rowSums(manual_Theta)
```

With the required inputs defined, we can simulate data using the following code: 

```{r simData}
sim_data <- simulate_validatedData(
    n_datasets = 50,
    nsites = nsites, 
    nvisits = nvisits, 
    nspecies = nspecies, 
    design_type = "FixedPercent", 
    scenarios = c(0.05, 0.1, 0.15, 0.3, 0.5),
    psi = psi, 
    lambda = lambda,
    theta = Theta, 
    save_datasets = FALSE, # default value is FALSE
    save_masked_datasets = FALSE, # default value is FALSE
    directory = here::here("Vignette", "Fixed_Effort")
)
```

Note that we specified the design type through the argument `design_type = "FixedPercent"`, with the possible scenarios defined by `scenarios = c(0.05, 0.1, 0.15, 0.3, 0.5)`. These two arguments specify the set of alternative validation designs we will compare in our simulation study. Under the first validation design, 5% of recordings from the first visit to a site are validated, while in the second validation design 10% of recordings from the first visit to a site are validated, and so on. 

To understand the output from `simulate_validatedData`, we can investigate `sim_data`. The output is a list, containing three objects:

-   `full_datasets`: A list of length `n_datasets` with unmasked datasets (i.e., the datasets if all recordings were validated so that every recording has an autoID and a true species label). We opted to not save these datasets by setting `save_datasets = FALSE`. If `save_datasets = TRUE`, then these will be saved individually in `directory` as `dataset_n.rds`, where `n` is the dataset number.
-   `zeros`: A list of length `n_datasets` containing the true species- autoID combinations that were never observed at each site visit. For example, if, in dataset 10, there were no calls from species 1 that were classified as 3 on visit 4 to site 30, then the 10th entry of this list would contain a dataset with a row corresponding to site = 30, visit = 4, true_spp = 1, id_spp = 3, with count = 0. These zeros are necessary for the model to identify occurrence probabilities and relative activity rates. If `save_datasets = TRUE`, the zeros for each dataset will also be saved in `directory` individually as `zeros_in_dataset_n.rds`, where `n` is the dataset number.
-   `masked_dfs`: A nested list containing each dataset masked under each scenario. For example, `masked_dfs[[9]][[27]]` contains dataset 27, assuming validation scenario 9. If `save_masked_datasets = TRUE`, then each dataset/scenario combination is saved individually in `directory` as dataset_n_masked_under_scenario_s.rds, where n is the dataset number and s is the scenario number.

Examples of each are given below:

```{r fullDfs}
full_dfs <- sim_data$full_datasets
head(full_dfs[[3]]) # Dataset number 3 if all recordings were validated
```

```{r zeros}
zeros <- sim_data$zeros

# The site-visit-true_spp-autoID combinations that were never observed in
# dataset 3. Notice that count = 0 for all rows! 
head(zeros[[3]]) 
```

```{r mdfs}
masked_dfs <- sim_data$masked_dfs

# View dataset 3 subjected to the validation design in scenario 4: 
# randomly select and validate 30% of recordings from the first visit 
# to each site 
head(masked_dfs[[4]][[3]])
```

For most simulations, it will be useful to summarize the number of recordings that are validated under a given validation design and scenario. This can be accomplished using the `summarize_n_validated` function, which outputs a vector containing the average number of recordings validated in a dataset under each scenario. Note that in our example, there are 8 scenarios (each contained in a row of the `val_scenarios` dataframe), meaning that the output is of length 8:

```{r sumN}
summarize_n_validated(data_list = sim_data$masked_dfs, theta_scenario = "1", scenario_names = 1:5)
```


## Step 4: MCMC_tuning

Running a complete simulation study can be time consuming. In an effort to help users improve the efficiency of their simulations, we provide the `tune_mcmc` function, which provides the user with information about the warmup and number of iterations required for the MCMC to reach approximate convergence.  This function takes in a masked dataset and the corresponding zeros, fits a model to these data, and outputs an estimated run time for 10,000 iterations, as well as the estimated number of required warmup and total iterations. 

As in the main text, we use a dataset with the lowest number of validated recordings, for which we expect the greatest number of iterations. In our example, this is scenario 1, in which an average of $\approx 55$ recordings are validated per dataset. When we run `tune_mcmc` with dataset 39 under scenario 1, we get an error message, telling us that convergence was not reached in under 10,000 iterations. We have several options: 

1. We could increase the number of iterations above 10,000 -- perhaps to 20,000 and settle for a longer run time of the simulation study.

2. We could take this as a sign that the level of effort ($55$ calls validated per dataset of size $\approx 3300$) is insufficient to identify model parameters. In this case, this scenario should not be considered. 

In our experience fitting these models, the second option seems to often be the case. We adopt this approach here and run `tune_mcmc` again under scenario 2: 

```{r tune, cache=TRUE}
tune_list <- tune_mcmc(dataset = sim_data$masked_dfs[[2]][[39]], zeros = sim_data$zeros[[39]])
```

We can see from the output that minimum number of iterations is 2000 with a warmup of 1000: 

```{r}
tune_list$min_iter
tune_list$min_warmup
```

If we were to specify 10,000 iterations per dataset, each model fit would take approximately 2 minutes. 
```{r}
tune_list$max_iter_time
```
This may seem insignificant, but over the course of an entire simulations study with 5 scenarios $\times$ 50 datasets, that corresponds to around 8 hours of run time. 

To understand the MCMC in greater detail, we can examine the `convergence_matrix` output 

```{r}
tune_list$convergence_matrix
```

We emphasize that these results are from a single model fit; they are supplied only as guidelines, so it may be a good idea to increase the number of iterations above the minimum values output from `tune_mcmc`. This is what we do in the following section, where we specify that there should be 3000 iterations with the first 1500 discarded as warmup. 

## Step 5: Fit models to simulated data

The following code block shows our use of `run_sims` to fit models to simulated data.

```{r run, cache=TRUE}
# reduce the size of the list since validation scenario 1 is too low: 
# we want scenarios 2-5 for fitting
masked_dfs_reduced <- masked_dfs[2:5]

sims_output <- run_sims(
         data_list = masked_dfs_reduced, 
         zeros_list = sim_data$zeros, 
         DGVs = list(lambda = lambda, psi = psi, theta = Theta), 
         theta_scenario_id = "FE", # for "fixed effort"
         parallel = TRUE, 
         niter = 3000, 
         nburn = 1500,  
         thin = 1,
         save_fits = TRUE, 
         save_individual_summaries_list = FALSE, 
         directory = here::here("Vignette", "Fixed_Effort")
)
```

## Step 6: Visualize simulations

Once the simulation study is complete, you can visualize the results using several functions.  `visualize_parameter_group` and `visualize_single_parameter`. These functions ensure that only converged models are included in the visualization. `visualize_parameter_group` is useful for examining an entire set of parameters, such as all relative activity parameters. The set of expected inputs for `visualize_parameter_group` are:

-   `sim_summary`: A dataframe in the format of the summaries output by `run_sims`. Column names must match those of the `run_sims` output.
-   `pars`: The name of the parameter "group" to be visualized (e.g, "psi", "lambda" or "theta").
-   `theta_scenario`: The $\Theta$ classifier ID.
-   `scenarios`: Which scenarios to visualize?
-   `convergence_threshold`: What value should $\hat{R}$ be below to be considered "converged"? Default value is 1.1. This value matters because only model fits where all parameter values are below the `convergence_threshold` are used for visualization.

We can visualize the inference for the relative activity parameters in the first three scenarios in our simulation study above by running the code below. Note that we have set `convergence_threshold` to be unrealistically high for illustration purposes. Typically, the default value of 1.1 is as high of an $\hat{R}$ value as possible for the MCMC chains to be considered "converged".

```{r vizGroup, eval=FALSE}
visualize_parameter_group(sim_summary = sims_output, 
                          pars = "lambda", 
                          theta_scenario = 1, 
                          scenarios = 1:4, # recall that scenario 1 in the figure is actually scenario 2 IRL
                          convergence_threshold = 1.1)
```

The features of the plot are as follows:

-   Facet grids: parameters
-   X-axis: Manual verification scenario
-   y-axis: parameter values
-   Small grey error bars: 95% posterior interval for an individual model fit where all parameters were below `convergence_threshold`.
-   Colored error bars: average 95% posterior interval across all converged models under that scenario.
-   Color: Coverage, or the rate at which 95% posterior intervals contain the true data-generating parameter value.
-   Black dots: the true value of the parameter
-   Red dots: average posterior mean

If you would like to visualize a single parameter, use `visualize_single_parameter`, which takes the same arguments as the previous visualization function:

```{r vizOne, eval=FALSE}
visualize_single_parameter(sims_output, par = "theta[2, 1]", 
                           theta_scenario = 1, 
                           scenarios = 1:3, 
                           convergence_threshold = 1.2)
```

Note that the scale of the y-axis is free to change from one visualization to the next. Additionally, if no datasets show evidence of convergence (i.e., no fitted models have $\hat{R} \leq c$ for all parameters, where $c$ is the specified convergence threshold) under a given scenario, the scenario will not appear on the x-axis.

# Conclusion 

We have demonstrated the use of the `ValidationExplorer` package. Note that with any simulation study results are conditional on the settings and assumptions. In the case of the count-detection model framework, the assumptions are 

- The occurrence of species within a site are independent; the presence of one species carries no information about the presence or absence of another. 
- For any one species, its occurrence at one location is independent of its occurrence at any other location (independence across sites).
- Visits to a site (i.e., detector nights) are independent. 
- Recordings within the same site-visit are independent. This holds regardless of whether a recording is validated or remains ambiguous (only has an autoID label). 
- The count of recordings generated by a species in a single detector night is a Poisson random variable. 
- All species in the assemblage can co-occur and are capable of being confused (no structural zeros in the classification matrix). 

\noindent The settings include the number of datasets used in the simulations, the assumed characteristics of the species assemblage (i.e., the values for each $\psi_k$ and $\lambda_k$) and classifier ($\Theta$), and the number of sites and visits. Our hope is that the ValidationExplorer provides a useful tool for assessing the merits of various validation designs, so that effort can be thoughtfully assigned based on program goals and monitoring objectives. Ultimately, we hope that this software streamlines the bat acoustic workflow and allows for efficient processing of information. 

# References

